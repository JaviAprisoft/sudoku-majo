<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sudoku · Bizcochito 1.0</title>
  <style>
    :root{
      --bg: #f6f6f7;
      --card: #ffffff;
      --text: #111827;
      --muted: #6b7280;
      --line: #d1d5db;
      --line-strong: #9ca3af;
      --focus: #e5e7eb;
      --error: #ef4444;
      --shadow: 0 10px 30px rgba(0,0,0,.06);
      --radius: 18px;
      --t: 140ms;
      --ease: cubic-bezier(.2,.8,.2,1);
    }

    *{ box-sizing: border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: var(--bg);
      color: var(--text);
    }

    .wrap{
      max-width: 980px;
      margin: 0 auto;
      padding: 28px 18px 40px;
      display: grid;
      gap: 18px;
      grid-template-columns: 1.2fr .8fr;
    }
    @media (max-width: 900px){ .wrap{ grid-template-columns: 1fr; } }

    .card{
      background: var(--card);
      border: 1px solid rgba(0,0,0,.04);
      box-shadow: var(--shadow);
      border-radius: var(--radius);
      overflow: hidden;
    }

    .header{
      padding: 18px 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      border-bottom: 1px solid rgba(0,0,0,.05);
    }

    .brand{ display:flex; align-items: baseline; gap: 10px; }
    .brand h1{
      margin:0;
      font-size: 18px;
      letter-spacing: .08em;
      text-transform: uppercase;
      font-weight: 700;
    }
    .brand .tag{
      font-size: 12px;
      color: var(--muted);
      letter-spacing: .08em;
      text-transform: uppercase;
    }

    .controls{
      display:flex;
      align-items:center;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    select, button{
      appearance: none;
      border: 1px solid rgba(0,0,0,.10);
      background: #fff;
      color: var(--text);
      border-radius: 999px;
      padding: 10px 12px;
      font-size: 13px;
      line-height: 1;
      cursor: pointer;
      transition: transform var(--t) var(--ease), background var(--t) var(--ease), border-color var(--t) var(--ease), box-shadow var(--t) var(--ease);
      outline: none;
      white-space: nowrap;
    }

    select{
      padding-right: 34px;
      background-image:
        linear-gradient(45deg, transparent 50%, var(--muted) 50%),
        linear-gradient(135deg, var(--muted) 50%, transparent 50%),
        linear-gradient(to right, transparent, transparent);
      background-position:
        calc(100% - 18px) calc(50% - 2px),
        calc(100% - 12px) calc(50% - 2px),
        calc(100% - 2.4em) 0.5em;
      background-size:
        6px 6px,
        6px 6px,
        1px 1.5em;
      background-repeat: no-repeat;
    }

    button:hover, select:hover{ border-color: rgba(0,0,0,.18); }
    button:active{ transform: translateY(1px); }

    .btn-ghost{ background: rgba(0,0,0,.02); }
    .btn-primary{
      background: var(--text);
      color: #fff;
      border-color: rgba(0,0,0,.35);
    }

    .content{ padding: 18px 18px 22px; }

    /* Board */
    .board{
      width: 100%;
      aspect-ratio: 1/1;
      display:grid;
      grid-template-columns: repeat(9, 1fr);
      border: 2px solid var(--line-strong);
      border-radius: 14px;
      overflow: hidden;
      user-select: none;
      background:#fff;
    }

    .cell{
      position: relative;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 20px;
      font-weight: 600;
      color: var(--text);
      background: #fff;
      border-right: 1px solid var(--line);
      border-bottom: 1px solid var(--line);
      cursor: pointer;
      transition: background var(--t) var(--ease), color var(--t) var(--ease), transform var(--t) var(--ease), box-shadow var(--t) var(--ease);
    }
    .cell .val{ line-height: 1; transform: translateY(1px); }

    .cell:nth-child(9n){ border-right: none; }
    .cell:nth-last-child(-n + 9){ border-bottom: none; }

    .cell.sep-r{ border-right: 2px solid var(--line-strong); }
    .cell.sep-b{ border-bottom: 2px solid var(--line-strong); }

    .cell.given{
      font-weight: 700;
      color: #111827;
      background: rgba(0,0,0,.02);
      cursor: default;
    }

    /* Selection + lane */
    .cell.selected{ background: var(--focus); }
    .cell.lane{ background: rgba(229,231,235,.78); }

    /* Same-number */
    .cell.same{ background: rgba(17,24,39,.075); }
    .cell.selected.same{ box-shadow: inset 0 0 0 2px rgba(0,0,0,.12); }

    /* Errors */
    .cell.conflict{ background: rgba(239,68,68,.10); color: #991b1b; }
    .cell.wrong{ background: rgba(239,68,68,.07); color: #991b1b; }
    .cell.conflict-peer{ box-shadow: inset 0 0 0 2px rgba(239,68,68,.28); }

    .cell .mini{
      position:absolute;
      top: 7px;
      right: 8px;
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: rgba(0,0,0,.15);
      opacity: 0;
    }
    .cell.selected .mini{ opacity: 1; background: rgba(0,0,0,.22); }

    .cell.flash{ animation: flashError .35s ease; }
    @keyframes flashError{
      0%{ background: rgba(239,68,68,.20); }
      100%{ background: rgba(239,68,68,.10); }
    }

    .cell.pop{ animation: popOk 140ms var(--ease); }
    @keyframes popOk{ 0%{ transform: scale(.98);} 100%{ transform: scale(1);} }

    /* Sidebar */
    .side{
      padding: 18px 18px 22px;
      display:flex;
      flex-direction: column;
      gap: 14px;
    }

    .meta{ display:flex; gap: 10px; flex-wrap: wrap; }
    .pill{
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(0,0,0,.08);
      background: rgba(0,0,0,.02);
      font-size: 13px;
      color: var(--muted);
      display:flex;
      align-items:center;
      gap: 8px;
    }
    .pill strong{ color: var(--text); font-weight: 700; }

    .keypad{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin-top: 6px;
    }

    .key{
      position: relative;
      border-radius: 16px;
      border: 1px solid rgba(0,0,0,.10);
      background: #fff;
      font-size: 18px;
      font-weight: 700;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor: pointer;
      transition: transform var(--t) var(--ease), background var(--t) var(--ease), border-color var(--t) var(--ease), box-shadow var(--t) var(--ease);
      user-select: none;
      min-width: 0;
      height: 56px;
    }

    .key:hover{ border-color: rgba(0,0,0,.18); }
    .key:active{ transform: translateY(1px); }
    .key.num{ height: 72px; }

    .key.action{
      height: 44px;
      border-radius: 999px;
      font-size: 11px;
      font-weight: 800;
      letter-spacing: .10em;
      text-transform: uppercase;
      white-space: nowrap;
    }

    .key.active{ background: rgba(229,231,235,.9); border-color: rgba(0,0,0,.20); }
    .key.active::after{
      content:"";
      position:absolute;
      bottom: 10px;
      width: 18px;
      height: 2px;
      border-radius: 999px;
      background: rgba(0,0,0,.35);
    }

    .key:disabled,
    .key[aria-disabled="true"]{
      opacity: .35;
      cursor: not-allowed;
      background: rgba(0,0,0,.02);
    }
    .key:disabled:hover{ border-color: rgba(0,0,0,.10); }

    .hint{
      margin-top: 6px;
      font-size: 12.5px;
      color: var(--muted);
      line-height: 1.5;
    }

    .toast{
      display:none;
      margin-top: 10px;
      padding: 12px 14px;
      border-radius: 14px;
      border: 1px solid rgba(22,163,74,.18);
      background: rgba(22,163,74,.08);
      color: #166534;
      font-size: 13px;
    }
    .toast.show{ display:block; }

    .sr{ position:absolute; left:-9999px; }

    /* Mobile-first polish */
    @media (max-width: 720px){
      body{ background: #f3f4f6; }
      .wrap{ padding: 14px 12px 22px; gap: 12px; }
      .card{ border-radius: 16px; }

      .header{
        padding: 14px 14px;
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
      }

      .controls{ width: 100%; justify-content: flex-start; gap: 8px; }
      .controls select,
      .controls button{ padding: 10px 12px; font-size: 13px; }
      .controls #newGame,
      .controls #reset,
      .controls #share{ flex: 1 1 auto; }

      .content{ padding: 12px 12px 14px; }
      .side{ padding: 12px 12px 14px; }

      .board{ max-width: 88vw; margin: 0 auto; border-radius: 12px; }
      .cell{ font-size: 18px; }

      #mobileKeypadSlot .keypad{ max-width: 88vw; margin: 10px auto 0; gap: 8px; }
      #mobileKeypadSlot .key.num{ height: 62px; border-radius: 16px; }
      #mobileKeypadSlot .key.action{ height: 42px; }

      /* Stats at the end on mobile */
      .side{ display:flex; flex-direction: column; }
      .keypad-slot{ order: 1; }
      .hint{ order: 2; font-size: 12px; }
      #winToast{ order: 3; }
      .meta{ order: 4; }
    }
  </style>
</head>
<body>
  <div class="wrap">

    <div class="card">
      <div class="header">
        <div class="brand">
          <h1>Sudoku</h1>
          <div class="tag">Bizcochito 1.0</div>
        </div>

        <div class="controls">
          <label class="sr" for="difficulty">Dificultad</label>
          <select id="difficulty">
            <option value="easy">Fácil</option>
            <option value="medium">Media</option>
            <option value="hard">Difícil</option>
            <option value="expert">Experta</option>
          </select>
          <button id="newGame" class="btn-primary">Nueva</button>
          <button id="reset" class="btn-ghost">Reiniciar</button>
          <button id="share" class="btn-ghost">Copiar link</button>
        </div>
      </div>

      <div class="content">
        <div id="board" class="board" aria-label="Tablero de Sudoku"></div>
        <div id="mobileKeypadSlot" aria-label="Teclado (móvil)"></div>
      </div>
    </div>

    <div class="card">
      <div class="side">
        <div class="meta">
          <div class="pill">Dificultad: <strong id="difficultyLabel">Fácil</strong></div>
          <div class="pill">Fallos: <strong id="mistakes">0</strong></div>
          <div class="pill">Rellenas: <strong id="filled">0</strong>/81</div>
          <div class="pill">Tiempo: <strong id="timer">00:00</strong></div>
          <div class="pill">Mejor: <strong id="best">—</strong></div>
        </div>

        <div id="desktopKeypadSlot" class="keypad-slot">
          <div class="keypad" id="keypad"></div>
        </div>

        <div class="hint">
          • Click en una casilla y usa el teclado (1–9) o el panel inferior.<br>
          • Se resaltan los iguales del número activo o de la casilla seleccionada.<br>
          • Se marca error instantáneo si el movimiento es incorrecto (aunque no genere conflicto).
        </div>

        <div id="winToast" class="toast">✅ Sudoku completado. ¡Perfecto!</div>
      </div>
    </div>

  </div>

<script>
(() => {
  // --- Puzzles (0 = vacío) — validados y con solución única
  const PUZZLES = {
    easy: [
      { puzzle: "000001039053090000100200400020310097016072500904060120005620014231800900609107000" },
      { puzzle: "100006030738200060000307089070503800503000274400001000960005347341602050007400020" },
      { puzzle: "093000000450392187001005020000006008608009051045003000389500600027068530000237010" },
      { puzzle: "005006000070201500104835002003574020700100400001982750506407380010350060387000040" },
      { puzzle: "254300009109208005800900021013000008002030470086400000020753004075604032040090657" },
      { puzzle: "008705421100623005702804360060000200427030106003046007596081030080350004000002000" },
      { puzzle: "904732580000000370705600219091060005002184000070900600006000198007809063300416002" },
      { puzzle: "509806030000003000200700960093208006045360009006579080902087050084135090057600800" },
      { puzzle: "000862590782000000090710203904620300070908106016007900160009402020040009430070051" },
      { puzzle: "010504200607029080030870009500030742478010500300000918165003800703050001902100300" },
      { puzzle: "003007000200603715068000023012705098000300204090000160974510006506400900800976540" },
      { puzzle: "000074630000109700973600100700506403630042590400080260000800006319005870060320015" },
      { puzzle: "700098124820013057140600000590300800382900576061075000070000295003000008050200013" },
    ],
    medium: [
      { puzzle: "002900601700862300000100892024009560600501000500026100040600700300010400008750000" },
      { puzzle: "093410786170000050568030000002100004609380200700020035000008643400000000006000508" },
      { puzzle: "000305100005009020432007005009000417060010209051000008008073542000000003600904701" },
      { puzzle: "010800000040902000300000804700093025293400610100068037079000000608050040520004300" },
      { puzzle: "000256017005000200040089000006010340413500009052340106020004071030000600000805004" },
      { puzzle: "000038060863207005000600080209100008300720050700900340021000800590301026000002090" },
      { puzzle: "020860000000100050010092708490603002080059000003208000008025960035980100060000820" },
      { puzzle: "000030984039000201051080703000008092008692300000000800105040600090820007027001400" },
      { puzzle: "002694000090031002340000600714002060009140207020376000960010020005209010000050000" },
      { puzzle: "000040025090030800600807130703000648040300210106070000000005091000402300460710080" },
      { puzzle: "300000051004920000670805943000086090810007064520040007280001030901000008007000100" },
      { puzzle: "000100907037040000002073604240008005000201003300754000001987050085026700000010800" },
      { puzzle: "080700000029086400000530100702000060064017008091053002030025000270000900410079800" },
    ],
    hard: [
      { puzzle: "600025080370090400080400092000001240500000000400278000834000000200080000001540036" },
      { puzzle: "000041560090000002400059073076002000002560100850310000325000001009000080600000700" },
      { puzzle: "080000240005028017700300080050010306120630000300005000098006002007000409200900000" },
      { puzzle: "100407000540000807080003010320000000900701203010000000000600950060090040001004062" },
      { puzzle: "070060530000000104518043000053006001800007600004200005006070000300800000020039000" },
      { puzzle: "005020060020080003700600180000090400080070301500030070010200600008000210007500030" },
      { puzzle: "000090020800000500000026000649000010000060058500703960001200300003007005286000009" },
      { puzzle: "900034001700000400080069030004805000069001352002000000000006870040010020000008500" },
      { puzzle: "000856000060040200047020030073000500800000073006087090000005020089004300000000407" },
      { puzzle: "001037050090650103000001000870000901004005080200010000080090000009020500520170000" },
      { puzzle: "000500009164908000805000001900000006000005970000600402010080024040106000020300100" },
      { puzzle: "001020080000000000002045007904100600000300008000006420010059070070000201009708034" },
      { puzzle: "007009600000600501031000708020340059050000400470000006000002065060010040210000000" },
    ],
    expert: [
      { puzzle: "005007020800000000034980001020600000000300502300000000007004803000015400040760000" },
      { puzzle: "003000107100009000005080009000050000601000350400028000000900600000273008500000073" },
      { puzzle: "000500023000060000800003050600200070070084000002070001704905000005000002000600100" },
      { puzzle: "800300507000600030054000090900000406020080000000200000000003061190070000080026000" },
      { puzzle: "000002090400010600000930002500009040007000000100060900001000080706450000902300500" },
      { puzzle: "005810000800400700000000380000500001002000000908071500000000920000243000600080070" },
      { puzzle: "000008000001650807000900510500000004010030009300700061070000000000573600000406000" },
      { puzzle: "060001003200000005390600000000000010008700620130090087050009276000052000000000000" },
      { puzzle: "810005007402900050006000900900307000000060005064500090000006020000008010103000000" },
      { puzzle: "600002070003900008005000010300000060000290000006500009000037004000004000058000100" },
      { puzzle: "030002050008000360000060004000090000000800030071003082209000000000405008400010000" },
      { puzzle: "000000006010720000600050900700208050030015000008060004004690500090000200000000800" },
    ]
  };

  const els = {
    board: document.getElementById('board'),
    keypad: document.getElementById('keypad'),
    difficulty: document.getElementById('difficulty'),
    difficultyLabel: document.getElementById('difficultyLabel'),
    newGame: document.getElementById('newGame'),
    reset: document.getElementById('reset'),
    share: document.getElementById('share'),
    mistakes: document.getElementById('mistakes'),
    filled: document.getElementById('filled'),
    timer: document.getElementById('timer'),
    best: document.getElementById('best'),
    winToast: document.getElementById('winToast'),
  };

  const LS = {
    checkpoint: 'sudoku_checkpoint_v3',
    bestPrefix: 'sudoku_best_',
  };

  let timerInterval = null;
  let saveTimer = null;

  let state = {
    difficulty: 'easy',
    seed: 0,
    puzzleIndex: 0,
    puzzle: null,              // string 81
    solution: null,            // string 81 (si existe)
    unique: true,              // solución única
    wrong: new Array(81).fill(false),
    given: new Array(81).fill(false),
    values: new Array(81).fill(0),
    selected: -1,
    activeNumber: 0,
    activeLocked: false,
    mistakes: 0,
    elapsed: 0,
    solved: false,
    lastMove: -1,
  };

  // --- Helpers
  const idxRC = (r,c) => r*9+c;
  const rowOf = (i) => Math.floor(i/9);
  const colOf = (i) => i%9;

  function peersOf(i){
    const r = rowOf(i), c = colOf(i);
    const br = Math.floor(r/3)*3;
    const bc = Math.floor(c/3)*3;
    const set = new Set();
    for(let cc=0; cc<9; cc++) set.add(idxRC(r,cc));
    for(let rr=0; rr<9; rr++) set.add(idxRC(rr,c));
    for(let rr=br; rr<br+3; rr++) for(let cc=bc; cc<bc+3; cc++) set.add(idxRC(rr,cc));
    set.delete(i);
    return [...set];
  }

  function prettyDifficulty(d){
    return ({easy:'Fácil', medium:'Media', hard:'Difícil', expert:'Experta'})[d] || d;
  }

  function formatTime(sec){
    const s = Math.max(0, Math.floor(sec));
    const mm = String(Math.floor(s / 60)).padStart(2,'0');
    const ss = String(s % 60).padStart(2,'0');
    return `${mm}:${ss}`;
  }

  function randomSeed(){
    try{
      const a = new Uint32Array(1);
      crypto.getRandomValues(a);
      return a[0] >>> 0;
    } catch {
      return (Math.random() * 0xFFFFFFFF) >>> 0;
    }
  }

  function seedToIndex(seed, len){
    if(!len) return 0;
    return (seed >>> 0) % len;
  }

  function getBestSeconds(difficulty){
    try{
      const raw = localStorage.getItem(LS.bestPrefix + difficulty);
      const n = raw == null ? NaN : Number(raw);
      return Number.isFinite(n) ? n : null;
    } catch {
      return null;
    }
  }
  function setBestSeconds(difficulty, sec){
    try{
      localStorage.setItem(LS.bestPrefix + difficulty, String(sec));
    } catch {}
  }

  function normalizePuzzleString(puzzleStr){
    if(typeof puzzleStr !== 'string' || puzzleStr.length !== 81) return null;
    for(let i=0;i<81;i++){
      const ch = puzzleStr[i];
      if(ch < '0' || ch > '9') return null;
    }
    return puzzleStr;
  }

  function startTimer(){
    if(timerInterval) return;
    timerInterval = setInterval(() => {
      if(state.solved) return;
      state.elapsed += 1;
      els.timer.textContent = formatTime(state.elapsed);
    }, 1000);
  }
  function resetTimer(sec = 0){
    state.elapsed = sec;
    els.timer.textContent = formatTime(state.elapsed);
    startTimer();
  }

  function scheduleCheckpointSave(){
    if(saveTimer) clearTimeout(saveTimer);
    saveTimer = setTimeout(saveCheckpoint, 250);
  }

  function saveCheckpoint(){
    try{
      const payload = {
        v: 3,
        difficulty: state.difficulty,
        seed: state.seed >>> 0,
        puzzleIndex: state.puzzleIndex ?? 0,
        puzzle: state.puzzle,
        values: state.values.join(''),
        elapsed: state.elapsed,
        mistakes: state.mistakes,
      };
      localStorage.setItem(LS.checkpoint, JSON.stringify(payload));
    } catch {}
  }

  function loadCheckpoint(){
    try{
      const raw = localStorage.getItem(LS.checkpoint);
      if(!raw) return false;
      const data = JSON.parse(raw);
      if(!data || !data.puzzle || !data.difficulty) return false;
      const normalizedPuzzle = normalizePuzzleString(data.puzzle);
      if(!normalizedPuzzle) return false;

      loadPuzzleFromSeed(data.difficulty, data.seed ?? 0, data.puzzleIndex ?? null, normalizedPuzzle);

      if(typeof data.values === 'string' && data.values.length === 81){
        applyValuesString(data.values);
      }
      state.mistakes = Math.max(0, Number(data.mistakes) || 0);
      resetTimer(Math.max(0, Number(data.elapsed) || 0));
      render();
      return true;
    } catch {
      return false;
    }
  }

  // --- URL (incluye puzzle real para que el link nunca “cambie”)
  function parseHash(){
    const h = (location.hash || '').replace(/^#/, '');
    if(!h) return null;
    const sp = new URLSearchParams(h);
    const d = sp.get('d');
    const s = sp.get('s');
    const i = sp.get('i');
    const p = sp.get('p'); // puzzle string 81
    const v = sp.get('v');
    const t = sp.get('t');
    const m = sp.get('m');
    if(!d || s == null) return null;
    return {
      difficulty: d,
      seed: (Number(s) >>> 0),
      puzzleIndex: i == null ? null : (Number(i) | 0),
      puzzle: (typeof p === 'string' && p.length === 81) ? p : null,
      values: v,
      elapsed: t == null ? null : Number(t),
      mistakes: m == null ? null : Number(m),
    };
  }

  function encodeHash(){
    const sp = new URLSearchParams();
    sp.set('d', state.difficulty);
    sp.set('s', String(state.seed >>> 0));
    sp.set('i', String(state.puzzleIndex ?? 0));
    sp.set('p', String(state.puzzle || ''));
    sp.set('v', state.values.join(''));
    sp.set('t', String(state.elapsed));
    sp.set('m', String(state.mistakes));
    return '#' + sp.toString();
  }

  async function copyToClipboard(text){
    try{
      await navigator.clipboard.writeText(text);
      return true;
    } catch {
      try{
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.setAttribute('readonly','');
        ta.style.position = 'fixed';
        ta.style.opacity = '0';
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        return true;
      } catch {
        return false;
      }
    }
  }

  function loadFromUrl(){
    const parsed = parseHash();
    if(!parsed) return false;

    const diff = PUZZLES[parsed.difficulty] ? parsed.difficulty : 'easy';
    const normalizedPuzzle = normalizePuzzleString(parsed.puzzle);
    loadPuzzleFromSeed(diff, parsed.seed, parsed.puzzleIndex, normalizedPuzzle);

    if(normalizedPuzzle && typeof parsed.values === 'string' && parsed.values.length === 81){
      applyValuesString(parsed.values);
    }

    state.mistakes = Math.max(0, Number(parsed.mistakes) || 0);
    resetTimer(Number.isFinite(parsed.elapsed) ? Math.max(0, parsed.elapsed) : 0);
    render();
    return true;
  }

  // --- Rendering
  function buildBoard(){
    els.board.innerHTML = '';
    for(let i=0;i<81;i++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.i = String(i);

      const r = rowOf(i), c = colOf(i);
      if(c === 2 || c === 5) cell.classList.add('sep-r');
      if(r === 2 || r === 5) cell.classList.add('sep-b');

      const val = document.createElement('div');
      val.className = 'val';
      cell.appendChild(val);

      const mini = document.createElement('div');
      mini.className = 'mini';
      cell.appendChild(mini);

      cell.addEventListener('click', () => selectCell(i));
      els.board.appendChild(cell);
    }
  }

  function buildKeypad(){
    els.keypad.innerHTML = '';

    for(let n=1;n<=9;n++){
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'key num';
      btn.textContent = String(n);
      btn.dataset.n = String(n);
      btn.addEventListener('click', () => {
        if(btn.disabled) return;
        state.activeNumber = n;
        state.activeLocked = true;
        render();
        applyNumberToSelected(n);
      });
      els.keypad.appendChild(btn);
    }

    const erase = document.createElement('button');
    erase.type = 'button';
    erase.className = 'key action';
    erase.textContent = 'Borrar';
    erase.addEventListener('click', () => {
      state.activeNumber = 0;
      state.activeLocked = false;
      applyNumberToSelected(0);
    });
    els.keypad.appendChild(erase);

    const clearSel = document.createElement('button');
    clearSel.type = 'button';
    clearSel.className = 'key action';
    clearSel.textContent = 'Deseleccionar';
    clearSel.addEventListener('click', () => {
      state.selected = -1;
      state.activeNumber = 0;
      state.activeLocked = false;
      render();
    });
    els.keypad.appendChild(clearSel);

    const highlight = document.createElement('button');
    highlight.type = 'button';
    highlight.className = 'key action';
    highlight.textContent = 'Resaltar';
    highlight.title = 'Resalta los iguales del número de la casilla seleccionada';
    highlight.addEventListener('click', () => {
      if(state.selected >= 0){
        const v = state.values[state.selected] || 0;
        state.activeNumber = v;
        state.activeLocked = false;
        render();
      }
    });
    els.keypad.appendChild(highlight);
  }

  function computeConflicts(valuesArr){
    const conflicts = new Set();
    for(let i=0;i<81;i++){
      const v = valuesArr[i];
      if(v === 0) continue;
      for(const p of peersOf(i)){
        if(valuesArr[p] === v){
          conflicts.add(i);
          conflicts.add(p);
        }
      }
    }
    return conflicts;
  }

  function getHighlightNumber(){
    if(state.activeNumber > 0) return state.activeNumber;
    if(state.selected >= 0){
      const v = state.values[state.selected];
      if(v > 0) return v;
    }
    return 0;
  }

  function render(){
    els.difficultyLabel.textContent = prettyDifficulty(state.difficulty);
    els.mistakes.textContent = String(state.mistakes);

    const filledCount = state.values.filter(v => v !== 0).length;
    els.filled.textContent = String(filledCount);

    els.timer.textContent = formatTime(state.elapsed);
    const bestSec = getBestSeconds(state.difficulty);
    els.best.textContent = bestSec == null ? '—' : formatTime(bestSec);

    // keypad disable when complete (9/9)
    const counts = new Array(10).fill(0);
    for(const v of state.values){ if(v > 0) counts[v] += 1; }

    if(state.activeNumber > 0 && counts[state.activeNumber] >= 9){
      state.activeNumber = 0;
      state.activeLocked = false;
    }

    const highlightN = getHighlightNumber();

    [...els.keypad.querySelectorAll('.key.num')].forEach(btn => {
      const n = Number(btn.dataset.n);
      const done = counts[n] >= 9;
      btn.disabled = done;
      btn.setAttribute('aria-disabled', done ? 'true' : 'false');
      btn.classList.toggle('active', n === highlightN && n > 0);
    });

    const solvedNow = checkSolved();
    if(solvedNow && !state.solved){
      const prevBest = getBestSeconds(state.difficulty);
      if(prevBest == null || state.elapsed < prevBest){
        setBestSeconds(state.difficulty, state.elapsed);
        const b2 = getBestSeconds(state.difficulty);
        els.best.textContent = b2 == null ? '—' : formatTime(b2);
      }
    }
    state.solved = solvedNow;
    els.winToast.classList.toggle('show', solvedNow);

    const conflicts = computeConflicts(state.values);

    // Explain conflict peers for selected (más explicativo)
    const explainPeers = new Set();
    let explainOn = false;
    if(state.selected >= 0){
      const sv = state.values[state.selected];
      if(sv > 0){
        for(const p of peersOf(state.selected)){
          if(state.values[p] === sv) explainPeers.add(p);
        }
        explainOn = explainPeers.size > 0;
      }
    }

    const cells = els.board.querySelectorAll('.cell');
    for(const cell of cells){
      const i = Number(cell.dataset.i);
      const v = state.values[i];
      const isGiven = state.given[i];
      const isSelected = i === state.selected;

      cell.classList.toggle('given', isGiven);
      cell.classList.toggle('selected', isSelected);

      if(state.selected >= 0){
        const sr = rowOf(state.selected), sc = colOf(state.selected);
        const r = rowOf(i), c = colOf(i);
        cell.classList.toggle('lane', (r===sr || c===sc) && !isSelected);
      } else {
        cell.classList.remove('lane');
      }

      const same = highlightN > 0 && v === highlightN;
      cell.classList.toggle('same', same);

      const hasConflict = conflicts.has(i) && v !== 0;
      cell.classList.toggle('conflict', hasConflict);

      const wrong = (!isGiven && v !== 0) ? !!state.wrong[i] : false;
      cell.classList.toggle('wrong', wrong && !hasConflict);

      cell.classList.toggle('conflict-peer', explainOn && (i === state.selected || explainPeers.has(i)));

      const val = cell.querySelector('.val');
      if(val) val.textContent = v === 0 ? '' : String(v);
    }
  }

  // --- Interaction
  function selectCell(i){
    state.selected = i;

    // Evita resaltado "pegado"
    const v = state.values[i] || 0;
    if(state.activeLocked && v > 0 && state.activeNumber !== v){
      state.activeNumber = 0;
      state.activeLocked = false;
    }
    if(v > 0 && !state.activeLocked){
      state.activeNumber = 0;
    }

    render();
  }

  function getConflictPeers(i, v){
    if(!v) return [];
    const peers = [];
    for(const p of peersOf(i)){
      if(state.values[p] === v) peers.push(p);
    }
    return peers;
  }

  function flashCells(indices){
    const uniq = [...new Set(indices)].filter(n => Number.isFinite(n));
    for(const i of uniq){
      const el = els.board.querySelector(`.cell[data-i="${i}"]`);
      if(!el) continue;
      el.classList.remove('flash');
      void el.offsetWidth;
      el.classList.add('flash');
      el.addEventListener('animationend', () => el.classList.remove('flash'), { once: true });
    }
  }

  function popCell(i){
    const el = els.board.querySelector(`.cell[data-i="${i}"]`);
    if(!el) return;
    el.classList.remove('pop');
    void el.offsetWidth;
    el.classList.add('pop');
    el.addEventListener('animationend', () => el.classList.remove('pop'), { once: true });
  }

  function applyValuesString(valuesStr){
    if(typeof valuesStr !== 'string' || valuesStr.length !== 81) return;
    for(let i=0;i<81;i++){
      if(state.given[i]) continue;
      const ch = valuesStr[i];
      state.values[i] = (ch >= '0' && ch <= '9') ? Number(ch) : 0;
    }
    state.lastMove = -1;
    recomputeWrongMarks();
  }

  function applyNumberToSelected(n){
    if(state.selected < 0) return;
    const i = state.selected;
    if(state.given[i]) return;

    // No permitir números completos (9/9)
    if(n > 0){
      let cnt = 0;
      for(const v of state.values){ if(v === n) cnt += 1; }
      if(cnt >= 9) return;
    }

    const before = state.values[i];
    state.values[i] = n;
    state.lastMove = i;

    recomputeWrongMarks();

    if(n !== before){
      if(n !== 0){
        const conflictPeers = getConflictPeers(i, n);
        const isWrong = !!state.wrong[i];
        if(conflictPeers.length || isWrong){
          state.mistakes += 1;
          flashCells([i, ...conflictPeers]);
        } else {
          popCell(i);
        }
      }
    }

    scheduleCheckpointSave();
    render();
  }

  // Keyboard
  window.addEventListener('keydown', (e) => {
    const key = e.key;

    if(key === 'Escape'){
      state.selected = -1;
      state.activeNumber = 0;
      state.activeLocked = false;
      render();
      return;
    }

    if(state.selected < 0) return;

    if(key >= '1' && key <= '9'){
      const n = Number(key);
      let cnt = 0;
      for(const v of state.values){ if(v === n) cnt += 1; }
      if(cnt >= 9) return;

      state.activeNumber = n;
      state.activeLocked = true;
      render();
      applyNumberToSelected(n);
      return;
    }

    if(key === 'Backspace' || key === 'Delete' || key === '0'){
      state.activeNumber = 0;
      state.activeLocked = false;
      applyNumberToSelected(0);
      return;
    }

    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(key)){
      e.preventDefault();
      const r = rowOf(state.selected);
      const c = colOf(state.selected);
      let nr=r, nc=c;
      if(key==='ArrowUp') nr = Math.max(0, r-1);
      if(key==='ArrowDown') nr = Math.min(8, r+1);
      if(key==='ArrowLeft') nc = Math.max(0, c-1);
      if(key==='ArrowRight') nc = Math.min(8, c+1);
      selectCell(idxRC(nr,nc));
    }
  });

  // --- Solver (lógica robusta + unicidad)
  function hasAnyConflict(values){
    for(let r=0;r<9;r++){
      const seen = new Set();
      for(let c=0;c<9;c++){
        const v = values[idxRC(r,c)];
        if(!v) continue;
        if(seen.has(v)) return true;
        seen.add(v);
      }
    }
    for(let c=0;c<9;c++){
      const seen = new Set();
      for(let r=0;r<9;r++){
        const v = values[idxRC(r,c)];
        if(!v) continue;
        if(seen.has(v)) return true;
        seen.add(v);
      }
    }
    for(let br=0;br<3;br++){
      for(let bc=0;bc<3;bc++){
        const seen = new Set();
        for(let r=br*3;r<br*3+3;r++){
          for(let c=bc*3;c<bc*3+3;c++){
            const v = values[idxRC(r,c)];
            if(!v) continue;
            if(seen.has(v)) return true;
            seen.add(v);
          }
        }
      }
    }
    return false;
  }

  function candidates(values, i){
    if(values[i] !== 0) return [];
    const r = rowOf(i), c = colOf(i);
    const br = Math.floor(r/3)*3;
    const bc = Math.floor(c/3)*3;

    const used = new Set();
    for(let cc=0;cc<9;cc++) used.add(values[idxRC(r,cc)]);
    for(let rr=0;rr<9;rr++) used.add(values[idxRC(rr,c)]);
    for(let rr=br;rr<br+3;rr++) for(let cc=bc;cc<bc+3;cc++) used.add(values[idxRC(rr,cc)]);

    const out = [];
    for(let n=1;n<=9;n++) if(!used.has(n)) out.push(n);
    return out;
  }

  function findBestCell(values){
    let bestI = -1;
    let bestCands = null;
    for(let i=0;i<81;i++){
      if(values[i] !== 0) continue;
      const c = candidates(values, i);
      if(c.length === 0) return { i, cands: [] };
      if(bestCands == null || c.length < bestCands.length){
        bestI = i;
        bestCands = c;
        if(c.length === 1) break;
      }
    }
    return { i: bestI, cands: bestCands || [] };
  }

  function solveCount(values, limit){
    const { i, cands } = findBestCell(values);
    if(i === -1) return 1;
    if(cands.length === 0) return 0;

    let count = 0;
    for(const n of cands){
      values[i] = n;
      count += solveCount(values, limit - count);
      if(count >= limit){
        values[i] = 0;
        return count;
      }
      values[i] = 0;
    }
    return count;
  }

  function solveOne(values){
    const { i, cands } = findBestCell(values);
    if(i === -1) return values.slice();
    if(cands.length === 0) return null;

    for(const n of cands){
      values[i] = n;
      const out = solveOne(values);
      if(out) return out;
      values[i] = 0;
    }
    values[i] = 0;
    return null;
  }

  function computeSolution(valuesArr){
    const base = valuesArr.slice();
    if(hasAnyConflict(base)) return { solutionStr: null, unique: false, count: 0 };

    const count = solveCount(base.slice(), 2);
    const sol = solveOne(base.slice());
    return {
      solutionStr: sol ? sol.join('') : null,
      unique: count === 1,
      count,
    };
  }

  function isSolvable(valuesArr){
    if(hasAnyConflict(valuesArr)) return false;
    const count = solveCount(valuesArr.slice(), 1);
    return count > 0;
  }

  function recomputeWrongMarks(){
    state.wrong = new Array(81).fill(false);

    // Si tenemos solución única, marca incorrectos contra la solución (infalible)
    if(state.solution && state.unique){
      for(let i=0;i<81;i++){
        if(state.given[i]) continue;
        const v = state.values[i];
        if(v === 0) continue;
        if(v !== Number(state.solution[i])) state.wrong[i] = true;
      }
      return;
    }

    // Fallback ultra seguro: solo marca el último movimiento si deja el tablero sin solución
    if(state.lastMove >= 0 && state.values[state.lastMove] !== 0){
      if(!isSolvable(state.values)) state.wrong[state.lastMove] = true;
    }
  }

  function checkSolved(){
    if(state.values.some(v => v === 0)) return false;
    if(state.solution){
      for(let i=0;i<81;i++){
        if(state.values[i] !== Number(state.solution[i])) return false;
      }
      return true;
    }
    return computeConflicts(state.values).size === 0;
  }

  // --- Game lifecycle (elige SIEMPRE puzzle con solución única)
  function loadPuzzleFromSeed(difficulty, seed, puzzleIndexOverride = null, puzzleOverride = null){
    const list = (PUZZLES[difficulty] && PUZZLES[difficulty].length) ? PUZZLES[difficulty] : PUZZLES.easy;
    let idx = (puzzleIndexOverride == null)
      ? seedToIndex(seed, list.length)
      : Math.max(0, Math.min(list.length - 1, puzzleIndexOverride));

    let chosenPuzzle = null;
    let chosenIndex = idx;
    let meta = null;

    const normalizedOverride = normalizePuzzleString(puzzleOverride);
    if(normalizedOverride){
      const tmp = Array.from(normalizedOverride, ch => Number(ch));
      const m = computeSolution(tmp);
      if(m.solutionStr){
        chosenPuzzle = normalizedOverride;
        chosenIndex = idx;
        meta = m;
      }
    }

    if(!chosenPuzzle){
      // Busca el primero con solución única a partir del índice calculado
      for(let k=0;k<list.length;k++){
        const j = (idx + k) % list.length;
        const p = normalizePuzzleString(list[j].puzzle);
        if(!p) continue;
        const tmp = Array.from(p, ch => Number(ch));
        const m = computeSolution(tmp);
        if(m.solutionStr && m.unique){
          chosenPuzzle = p;
          chosenIndex = j;
          meta = m;
          break;
        }
      }
      // fallback: cualquiera con solución (por si te quedas sin únicos en el futuro)
      if(!chosenPuzzle){
        for(let k=0;k<list.length;k++){
          const j = (idx + k) % list.length;
          const p = normalizePuzzleString(list[j].puzzle);
          if(!p) continue;
          const tmp = Array.from(p, ch => Number(ch));
          const m = computeSolution(tmp);
          if(m.solutionStr){
            chosenPuzzle = p;
            chosenIndex = j;
            meta = m;
            break;
          }
        }
      }
      // último fallback: el primero válido (no debería pasar)
      if(!chosenPuzzle){
        for(let k=0;k<list.length;k++){
          const p = normalizePuzzleString(list[k].puzzle);
          if(!p) continue;
          chosenPuzzle = p;
          chosenIndex = k;
          const tmp = Array.from(p, ch => Number(ch));
          meta = computeSolution(tmp);
          break;
        }
      }
    }

    state.difficulty = difficulty;
    els.difficulty.value = difficulty;
    state.seed = (seed >>> 0);
    state.puzzleIndex = chosenIndex;
    state.puzzle = chosenPuzzle;

    state.given = new Array(81).fill(false);
    state.values = new Array(81).fill(0);
    state.selected = -1;
    state.activeNumber = 0;
    state.activeLocked = false;
    state.mistakes = 0;
    state.solved = false;
    state.lastMove = -1;

    for(let i=0;i<81;i++){
      const d = Number(state.puzzle[i]);
      if(d >= 1 && d <= 9){
        state.given[i] = true;
        state.values[i] = d;
      }
    }

    // Solución calculada de forma consistente
    state.solution = meta && meta.solutionStr ? meta.solutionStr : null;
    state.unique = !!(meta && meta.unique);

    recomputeWrongMarks();
    resetTimer(0);
    scheduleCheckpointSave();
    render();
  }

  function loadRandomPuzzle(difficulty){
    const seed = randomSeed();
    loadPuzzleFromSeed(difficulty, seed);
  }

  function resetToOriginal(){
    if(!state.puzzle) return;

    state.values = new Array(81).fill(0);
    state.given = new Array(81).fill(false);

    for(let i=0;i<81;i++){
      const d = Number(state.puzzle[i]);
      if(d >= 1 && d <= 9){
        state.given[i] = true;
        state.values[i] = d;
      }
    }

    state.selected = -1;
    state.activeNumber = 0;
    state.activeLocked = false;
    state.mistakes = 0;
    state.solved = false;
    state.lastMove = -1;

    recomputeWrongMarks();
    resetTimer(0);
    scheduleCheckpointSave();
    render();
  }

  // --- Mobile keypad placement
  const desktopKeypadSlot = document.getElementById('desktopKeypadSlot');
  const mobileKeypadSlot = document.getElementById('mobileKeypadSlot');

  function placeKeypadForViewport(){
    const isMobile = window.matchMedia('(max-width: 720px)').matches;
    const keypad = els.keypad;
    if(!keypad) return;

    if(isMobile){
      if(mobileKeypadSlot && keypad.parentElement !== mobileKeypadSlot){
        mobileKeypadSlot.appendChild(keypad);
      }
    } else {
      if(desktopKeypadSlot && keypad.parentElement !== desktopKeypadSlot){
        desktopKeypadSlot.appendChild(keypad);
      }
    }
  }

  // --- Wire up
  els.newGame.addEventListener('click', () => loadRandomPuzzle(els.difficulty.value));
  els.reset.addEventListener('click', resetToOriginal);
  els.difficulty.addEventListener('change', () => loadRandomPuzzle(els.difficulty.value));

  els.share.addEventListener('click', async () => {
    const newHash = encodeHash();
    try{ history.replaceState(null, '', newHash); } catch { location.hash = newHash; }

    const ok = await copyToClipboard(location.href);
    const prev = els.share.textContent;
    els.share.textContent = ok ? 'Copiado ✓' : 'No se pudo copiar';
    setTimeout(() => { els.share.textContent = prev; }, 900);
  });

  window.addEventListener('resize', () => {
    clearTimeout(window.__rt);
    window.__rt = setTimeout(placeKeypadForViewport, 120);
  });

  // Init
  buildBoard();
  buildKeypad();

  const loaded = loadFromUrl() || loadCheckpoint();
  if(!loaded) loadRandomPuzzle('easy');

  placeKeypadForViewport();
  startTimer();
})();
</script>
</body>
</html>
